-What is the tagless access buffer?
 *A small buffer placed at the top of the memory hierarchy
 *Holds a few lines from the L1D (inclusive)
 *Data explicitly directed from the L1D to the TAB by compiler generated instructions
 *Compiler looks in loops for references with constant strides or invariant
  addresses to direct to the TAB
 *QUICK description!
-What problem does it solve?
 *Energy efficiency is a major design constraint in processors
 *Cache accounts for up to 25% of a processor's total power draw
  (only if references can easily be added?)
 *TAB reduces overall cache energy usage
  +TAB uses less energy than the L1D because it is:
   #Smaller
   #Requires Far fewer DTLB accesses
   #Requires no tag check
 *Not too many details
-Why use references with constant stride or invariant address
 *We can calculate the following reference's address if the loop reference has
  a constant stride throughout the loop or if the address doesn't change.
 *Before the line is needed, we can prefetch the next line so it is available
  before it is accessed again.
 *No need to check tags since we can guarantee with prefetching that the TAB 
  entry has the line we need 
-TAB instructions
 *Two instructions control the TAB
  +gtab links a register to a TAB entry
   #once active, references with that base register will be directed to the TAB
   #gtab prefetches the line needed by the first TAB reference
   #Further prefetches are performed automatically when needed and keep the
    line data valid for the TAB references.
  +rtab removes the register link and deallocates the TAB
 *Both instructions use the same opcode; distinguished by a bit
  +Maybe image here?
X*Once you have enough information, talk about the changes to TAB
X*We may need to talk about the "updated" part much later so people understand
X the changes!
-Example TAB instruction generation (use figure 2.3)
 *Show original loop, "Simple summation"
 *Show RTLs without TAB instructions:
 *Show RTLs with TAB instructions: 
 *SHOULD show the prefetch image SOMEWHERE at least, but maybe wait until the
  prefetch section
-TAB hardware (description)
 *TAB itself to hold 4 lines from the L1D
 *Metadata structure for TAB and line metadata
 *4 entry register array stores the base register associated with each TAB
 *Valid window structure to indicate TAB validity per function call
-TAB hardware (image)
 *Use the hardware overview image 3.1
-TAB hardware (ID stage description)
 *Include the left side of hardware graphic
 *Memory references compare the base register number against each TAB
 associated register number in parallel
 *If any match AND the matching TAB is valid (AND bits from comparison and valid
 windows), direct that reference to the associated TAB
 *If none match, go to L1D
-TAB metadata (description and image)
 *show the metadata and buffer section of the image
 *Separate metadata for TAB entry and TAB line
  +Not necessarily a one to one relationship between TAB entries and TAB lines
 *Line and line metadata accessed through index field from TAB entry
 *Level of indirection between the TAB entry and TAB lines allows multiple
 TABs to share the same line
-TAB metadata (show actual tab metadata structure)
 *TAB metadata stores information about prefetching, the access type, and which line in
  the buffer it is using
  +access type helps save energy by stopping certain unnecessary line transfers
  +prefetch type and prefetch PC give information about how and when to
  prefetch
  +index and extra line 
-Line metadata (show actual line metadata structure)
 *Line metadata stores information which allows quick L1D access for writebacks
  and interferences
  +line number and way indicate the exact L1D location
  of the line
  +Physical page number removes the need to check the DTLB
  +includes a write mask so only dirty bytes are written back to l1d
-TAB Operations
-Compiler garbage
-Extra functionality
 *Avoiding unnecessary data transfers
-How well does it work? 
 *Results
-Conclusion
 *TAB does stuff blah blah blah

